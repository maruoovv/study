## 추상화 계층

코드 작성의 목적은 문제 해결이다. 우리는 의식하지는 못하지만 보통 문제를 풀 때 여러 개의 작은 하위 문제들로 나눈다.  
문제와 하위 문제를 어떻게 해결하는가도 중요하지만 그것들을 해결하는 코드를 어떻게 구성하는가도 중요하다.  

코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 추상화계층을 만드는 것으로 귀결될 때가 많다.  


### 왜 추상화 계층을 만드는가?  

사용자의 어떤 장치에서 실행되면서 서버에 메시지를 보내는 코드를 작성한다고 생각해보자

```
HttpConnection connection = HttpConnection.connect("http://example.org/server");
connection.send("Hello Server"); 
connection.close()
```

우리는 추상화된 코드를 사용하여 위와 같이 짧은 코드로 작성하지만, 실제로 내부에서는 다양한 일이 일어난다.

- 전송 형식에 맞추어 문자열 직렬화
- HTTP 프로토콜 동작, TCP 연결
- 와이파이, 네트워크 연결 등 확인
- 데이터 전송 및 오류 수정 

우리는 다행스럽게도 추상화된 코드를 사용하기 때문에, 하위 문제에 대해 상세히 몰라도 코드를 작성할 수 있다.

### 추상화 계층 및 코드 품질의 핵심 요소
깨끗하고 뚜렷한 추상화 계층을 구축하면 이전에 봤던 코드 품질의 네 가지 핵심요소를 달성할 수 있다.

#### 가독성
코드의 모든 세부 사항을 이해하는 것은 불가능하지만 몇 가지 높은 계층의 추상화를 이해하기는 쉽다.  
깨끗하고 뚜렷한 추상화 계층을 만드는 것은 한 번에 한두개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미하므로 가독성이 향상된다

#### 모듈화
추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내부에서 구현을 변경하기가 쉬워진다. 

#### 재사용성 및 일반화성
하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다.

#### 테스트 용이성
신뢰할 수 있는 코드를 작성하고자 한다면, 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인해야 한다.  
코드가 추상화 계층으로 깨끗하게 분할되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다.

---

### 코드의 계층
추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하는 것이다. 대체적으로 단위는 다음과 같다 

- 함수
- 클래스
- 인터페이스
- 패키지, 네임스페이스, 모듈

#### 함수 
함수가 하는 일을 다음 중 하나로 제한하면 이해하기 쉽고 단순한 문장으로 표현되는 함수를 작성할 수 있다.  
함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다.

#### 클래스 
클래스의 이상적인 크기와 역할에 대해 많은 이론과 법칙이 있다.

- 응집력 : 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 정도로, 좋은 클래스는 응집력이 강하다
- 관심사의 분리 : 시스템이 각각 별개의 문제를 다루는 개별 구성 요소로 분리되어야 한다는 원칙이다.

응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 **하나의 사항**으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.  
이건 주관적이기 때문에 까다로울 수 있다.  

클래스는 응집력이 있어야 하고 한 가지 일에만 관심을 가져야 한다라는 말은 대부분의 사람이 알고 있지만 지키기가 어렵다.  
단일 클래스 내에 얼마나 많은 다른 개념이 들어가 있는지, 어떤 로직이 재사용이나 재구성에 적합한지에 대해 신중하게 생각하지 않으면 클래스는 종종 너무 커진다.

클래스를 분리해야 할지 판단하기 위해서 앞의 네 가지 핵심 요소를 충족하는지 살펴보는 것이 좋을 수 있다.


#### 인터페이스 
계층을 뚜렷이 구분하고 구현 세부 사항이 노출되지 않도록 하기 위해 인터페이스를 사용할 수 있다.  
하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다.  
지금 당장 다르게 구현할 필요가 있을지 알 수 없더라도 이렇게 구현하면 몇 가지 장점이 있다.

- 퍼블릭 API를 명확하게 보여준다 : 사용해야 하는 기능을 노출하고 구현 세부 사항을 숨길 수 있다
- 한가지 구현만 필요하다고 잘못 추측한 것일 수 있다
- 테스트를 쉽게 할 수 있다 : 구현 클래스가 복잡하거나 외부 연결에 의존한다면 목이나 페이크 객체로 대체할 수 있다.

반면 다음과 같은 단점도 있다 
- 더 많은 작업이 필요하다
- 코드가 복잡해질 수 있다.

모든 클래스에 인터페이스를 붙이는 극단적인 코드는 불필요하게 복잡해지고 이해와 수정이 어렵다. 인터페이스만을 위한 인터페이스를 작성해서는 안 된다.

