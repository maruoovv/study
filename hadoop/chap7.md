## 맵리듀스 작동 방법

### 맵리듀스 잡 실행 상세분석 
하둡이 맵리듀스 잡을 실행하는 과정을 알아보자.  

![image](https://user-images.githubusercontent.com/37106689/77379797-efa3f380-6dbc-11ea-8a73-b983639dd28e.png)

상위 수준에서 보면 다섯 개의 독립적인 단계로 구분된다.

- 클라이언트 : 맵 리듀스 잡을 제출한다.
- YARN 리소스 매니저 : 클러스터 상에 계산 리소스의 할당을 제어한다.
- YARN 노드 매니저 : 클러스터의 각 머신에서 계산 컨테이너를 시작하고 모니터링한다.
- 맵리듀스 애플리케이션 마스터 : 맵리듀스 잡을 수행하는 각 태스크를 제어한다. 
- 분산 파일 시스템 : 다른 단계 간에 잡 리소스 파일들을 공유하는데 사용된다.

#### 잡 제출
잡을 제출하면 waitForCompletion() 메서드가 1초에 한 번씩 잡의 진행 상황을 조사하여 변경 내역을 콘솔로 보여준다.  
잡 제출 과정은 다음과 같다.

1. 리소스 매니저에 맵리듀스 잡 ID로 사용할 애플리케이션 ID 요청 (2)
2. 잡의 출력 명세를 확인하고 문제가 있을 시 에러 전달.
3. 잡의 입력 스플릿을 계산. 계산할 수 없다면 에러 전달.
4. 잡 실행에 필요한 JAR, 환경설정 파일, 입력 스플릿 등 리소스를 공유 파일시스템에 있는 해당 잡 ID 를 이름으로 하는 디렉터리에 복사. (3)
5. 리소스 매니저의 submitApplication 을 호출하여 잡 제출 (4)

#### 잡 초기화
리소스 매니저가 submitApplication 호출을 받으면 YARN 스케줄러에 요청을 전달한다.  
스케줄러는 컨테이너를 할당하고 애플리케이션 마스터 프로세스를 시작한다. (5a, 5b)

애플리케이션 마스터는 잡을 초기화할 때 잡의 진행 상태를 추적하기 위한 다수의 북키핑 객체를 생성하고, 각 태스크로부터 진행 및 종료 보고서를 받는다(6)  
다음으로 클라이언트가 계산한 입력 스플릿 정보를 공유 파일 시스템에서 읽어온다. (7)  
이후 입력 스플릿별로 맵 태스크 객체를 생성하고, 리듀스 객체를 생성한다.  

잡의 크기가 작다면 애플리케이션 마스터는 태스트를 자신의 JVM에서 실행할 수 있다.  
이러한 잡을 **우버 태스크** 또는 **우버되었다(uberized)** 라 한다.  
이런 일이 일어날 경우는, 병렬 처리를 위한 오버헤드 보다, 단일 노드에서 순차적으로 실행하는 것이 유리하다고 판단될 때다.  
우버 태스크를 활성화 하려면 반드시 mapreduce.job.ubertask.enable 속성을 true 로 해야한다.

#### 태스크 할당 
애플리케이션 마스터는 리소스 매니저에 잡의 모든 맵, 리듀스 태스크를 위한 컨테이너를 요청한다. (8)  
맵 태스크 요청이 리듀스 보다 우선순위가 높다. 리듀스의 정렬 단계 시작 전에 모든 맵 태스크가 완료되어야 하기 때문이다.  

리듀스 태스크는 클러스터의 어느 곳에서든 실행될 수 있지만, 맵 태스크는 스케줄러가 준수하는 데이터 지역성 제약이 있다. (데이터 로콜>랙 로컬)

#### 태스크 실행 
리소스가 태스크에 할당되면, 애플리케이션 마스터는 노드 매니저와 통신하며 컨테이너를 시작한다. (9a, 9b)  
각 태스크는 YarnChild 메인 클래스를 가진 자바 Application 으로 실행된다.  
태스크를 실행하기 전에 잡 환경 설정, JAR파일, 분산 캐시 파일 등 필요한 리소스를 로컬로 가져온 후, 맵과 리듀스 태스크를 실행한다.  

YarnChild는 별도 JVM에서 실행되기 떄문에 맵, 리듀스 함수에 버그가 발생하여도 노드매니저는 영향을 받지 않는다.

##### 스트리밍 
스트리밍 태스크는 표준 입출력 스트림을 통해 프로세스와 통신한다.  
태스크가 실행되는 동안 자바 프로세스는 키-값 쌍을 외부 프로세스에 전달하고, 이를 사용자 정의 맵/리듀스 함수로 처리한 뒤, 최종 출력 키-값 쌍을 자바 프로세스에 돌려준다.  
노드 매니저 관점에서는 자식 프로세스가 맵/리듀스 코드를 스스로 실행한 것처럼 보인다.

#### 진행 상황과 상태 갱신
맵리듀스 잡은 수행 시간이 오래 걸리므로, 사용자가 잡의 상황에 대해 피드백을 받는것은 매우 중요하다.  
잡과 개별 태스크는 상태, 맵/리듀스 진행 상황, 잡의 카운터 값, 상태 메시지 등의 상태 저보를 가진다.  
각 태스크는 자신의 진행 상황을 추적한다.  
맵과 리듀스 태스크는 실행되면서 부모인 애플리케이션 마스터와 통신한다. 진행상황과 상태 정보를 집계하여 인터페이스를 통해 마스터에 보고한다.  
잡이 진행되는 동안 클라이언트는 매초 마다 애플리케이션 마스터를 폴링하여 가장 최근의 상태를 받아온다.  

#### 잡 완료
애플리케이션 마스터가 마지막 태스크가 완료되었다는 통지를 받으면 잡의 상태를 '성공' 으로 변경한다.  
잡이 상태 정보를 폴링하면 해당 잡이 성공적으로 완료되었음을 알게 된다.


### 실패 
실제 환경에서는 사용자 코드의 버그로 인해 프로세스가 죽거나 서버에 장애가 발생하는 일이 많다.  
하둡의 가장 큰 장점은 이러한 실패를 잘 다루어 잡이 완료되도록 도와준다는 것이다.  
실패에는 크게 태스크, 애플리케이션 마스터, 노드 매니저, 리소스 매니저 실패가 있다.    

#### 태스크 실패 
가장 흔한 실패의 유형은 맵/리듀스 태스크 내 사용자 코드에서 런타임 예외를 던질 때다.  
예외가 발생하면 태스크 JVM 은 종료전에 부모인 애플리케이션 마스터에 에러를 보고한다.  
마스터는 이 태스크 시도를 실패로 표시하고 해당 리소스를 다른 태스크에서 사용 가능하도록 해준다.  

행이 걸린 태스크는 다르게 처리된다. 애플리케이션 마스터는 잠시 동안 진행 상황을 갱신 받지 못하면 해당 태스크를 실패로 표시 한다.  
태스크 JVM 프로세스는 이 기간 후에 자동으로 강제 종료된다.  

애플리케이션 마스터는 태스크 시도 실패를 알게 되면 해당 태스트 실행을 다시 스케줄링 한다.  
이전에 실패했던 노드 매니저에 해당 태스크를 다시 할당하는 것을 피하려 노력 한다.  
태스크가 네 번 실패하면 재시도 하지 않는다. (mapreduce.map.maxattempts, mapreduce.reduce.maxattempts)

#### 애플리케이션 마스터 실패 
YARN 의 애플리케이션도 실패할 때 몇 번의 재시도를 하게 된다.  
애플리케이션 마스터가 시도하는 최대 횟수는 mapreduce.am.max-attempts 속성으로 조절한다.  

YARN 은 클러스터에서 실행 중인 모든 YARN 애플리케이션 마스터에 대해 일괄적으로 최대 시도 횟수 제한을 줄 수 있으며 개별 앱은 이 횟수를 넘길 수 없다.  

복구 방식은 다음과 같다. 애플리케이션 마스터는 주기적으로 리소스 매니저에 하트비트를 보내고, 
마스터 실패 이벤트 발생 시 리소스 매니저는 이를 감지하여 새로운 컨테이너에서 실행할 새로운 마스터 인스턴스를 시작한다.

맵리듀스 클라이언트는 진행 상황 보고를 위해 마스터를 폴링하는데, 만약 이 마스터가 실패한다면 클라이언트는 새로운 마스터 인스턴스의 위치를 알아내야 한다.  
처음에 잡을 초기화하는 동안 클라이언트는 리소스 매니저에 마스터의 주소를 요청하고 캐싱 하여 폴링 시 매번 리소스 매니저에 요청하는 부담을 없앤다.  
만약 마스터가 실패하여 새 마스터 인스턴스가 생긴다면, 클라이언트가 상태 갱신을 전달할 때 타임아웃이 발생하고, 이때 클라이언트는 리소스 매니저에 새로운 마스터의 주소를 요청한다.  

#### 노드 매니저 실패 
노드 매니저가 실패하거나 굉장히 느리다면 리소스 매니저에 하트비트 전송을 중단하거나 드물게 전송한다.  
리소스 매니저는 일정 시간동안 노드 매니저로부터 하트비트 전송을 받지 못한다면 이 매니저를 컨테이너를 스케줄링 하는 풀에서 제거한다.  

실패한 노드 매니저에서 수행중인 애플리케이션 마스터나 태스크는 앞에서 설명한 메커니즘을 통해 복구된다.  

애플리케이션 실패 횟수가 높으면 노드 매니저가 실패하지 않았더라도 **블랙 리스트**에 등록된다.  

#### 리소스 매니저 실패
리소스 매니저 실패는 심각한 상황이다. 리소스 매니저 없이는 잡/태스크 컨테이너가 실행될수 없다.  
기본 환경 설정에서 리소스 매니저는 SPOF 이다.

고가용성을 달성하기 위해서는 두 개의 리소스 매니저를 활성대기(active-standby) 설정으로 실행해야 한다.  
실행중인 애플리케이션에 대한 모든 정보는 고가용 상태 저장소(주키퍼 or HDFS)에 보관되어 있어 대기 리소스 매니저는 실패한 리소스 매니저의 핵심 상태를 복구할 수 있다.  

새로운 리소스 매니저가 시작되면 상태 저장소로부터 애플리케이션 정보를 읽고 클러스터에서 실행 중인 모든 애플리케이션 마스터를 재시작한다.  
시스템에 의해 강제 종료된 것이므로 실패한 애플리케이션 시도로 세지는 않는다.  

standby 에서 active 로의 전환은 failover controller 가 담당한다.  
주키퍼 대표자 선출을 사용하여 어떠한 시점에서든 단일 active 리소스 매니저가 존재하도록 보장한다.


### 셔플과 정렬 
맵리듀스는 모든 리듀서의 입력이 키를 기준으로 정렬되는 것을 보장한다.  
시스템이 이러한 정렬을 수행하고 맵의 출력을 리듀서의 입력으로 전송하는 과정을 **셔플** 이라고 한다. 

#### 맵 부분 
맵 함수가 결과를 생산할 때 효율적인 처리를 위해 메모리에 일정 크기만큼 쓴 다음 사전 정렬을 수행한다.  

![image](https://user-images.githubusercontent.com/37106689/77395789-b2a02700-6de5-11ea-80ce-eec1b8711afb.png)


각 맵 태스크는 메모리 버퍼를 갖고 있고 이곳에 결과를 기록한다. (기본 100MB)   
버퍼의 내용이 특정 한계치에 도달하면 백그라운드 스레드가 디스크에 **스필** 을 시작한다.
(각 파티션별 메모리 버퍼를 디스크에 한번에 쓰는 것)  
스필이 일어나는 동안에도 맵 결과는 계속해서 버퍼에 쓰이는데, 버퍼가 가득 차면 스필이 완료될 때 까지 블록된다.  

스필 전에 스레드는 데이터를 최종적으로 전송할 리듀서 수에 맞게 파티션으로 나눈다.  
각 파티션 내의 백그라운드 스레드는 키를 기준으로 인메모리 정렬을 수행하고, 컴바이너 함수가 존재하면 수행한다.  
스필 파일은 여러개가 생성될 수 있다. 맵 태스크가 종료되기 전에 여러 스필 파일은 단일 출력 파일로 병합되고 정렬된다.  

#### 리듀스 부분 
리듀스 태스크는 클러스터 내에 퍼져 있는 많은 맵 태스크로부터 특정 파티션에 해당하는 맵 출력을 필요로 한다.  
리듀스 태스크는 각 맵 태스크의 출력이 끝나는 즉시 복사하기 시작한다. (복사 단계)  
리듀스 태스크는 소수의 복사기 스레드를 가지고 있는데, 이들은 맵 출력 인출을 병렬로 수행한다.  

맵 출력은 크기가 작다면 리듀스태스크 JVM 메모리에 복사된다.  
인메모리 버퍼가 한계치에 도달하거나 맵 출력 수가 한계치에 도달하면 병학되어 디스크에 스필된다.  

복사된 파일이 디스크에 축적되면 백그라운드 스레드가 이를 더 크고 정렬된 형태의 파일로 병합한다.  

모든 맵 출력이 복사되는 시점에 리듀스 태스크는 병합 단계로 이동하여 맵 출력을 병합하고 정렬 순서를 유지한다.  
이 작업은 라운드 단위로 이루어진다. 예를 들어 50개의 맵 출력이 존재하고 **병합계수**가 10이라면 다섯 개의 라운드로 구성된다.  
각 라운드는 10개의 파일을 하나로 병합하여 다섯개의 중간 파일리 생성된다.  

이 다섯 개의 파일을 하나의 정렬된 파일로 병합하는 최종 라운드를 가지는 대신 마지막 단계(리듀스 단계)의 리듀스 함수에 바로 전송하여 디스크 IO를 줄인다.

___
각 라운드에서 병합되는 파일 수는 위 설명보다 좀 더 복잡하다.  
궁극적인 목적은 최종 라운드에서 병합 계수에 도달하기 위해 최소한의 파일을 병합하는 것이다.  
파일이 40개 일 떄 라운드 4개로 파일을 10개씩 병합해서 파일 4개를 얻는 것이 아니라,  
첫 라운드 파일 4개, 2-3-4 파일 10개 씩 병합한다.  
마지막 라운드에는 4개의 병합된 파일과 병합되지 않은 6개의 파일이 남게 되어 총 10개의 파일이 최종 라운드에 생성된다.  

#### 설정 조정 
맵리듀스 성능 향상을 위한 셔플 튜닝 방법을 알아보자.  

일반적인 원칙은 셔플에 많은 메모리를 할당 하는 것이다.    
하지만 여기엔 트레이드오프가 존재하는데, 맵/리듀스 함수가 작동하는 데 충분한 메모리 확보가 필요하기 때문이다.  
따라서 맵/리듀스 함수를 가능한 한 적은 메모리를 사용하도록 하는것이 중요하다.  

맵 측면에서 보면 다수의 디스크 스필을 피하는 것이 성능 향상 방법이다.  
리듀스 측면에서는 중간 데이터 전체가 메모리에 존재할 때 최고의 성능을 낼 수 있다.  
일반적으로 이런 일은 발생하지 않는데, 리듀스 함수에 모든 메모리를 예약해두기 때문이다.


### 태스크 실행 
맵리듀스 사용자가 태스크 실행에 관해 취할 수 있는 좀 더 많은 제어사항을 알아보자.

#### 투기적 실행 
맵리듀스는 잡을 태스크로 나누고 태스크를 병렬 수행하는 형태다.  
이로 인해 잡 실행 시간은 느리게 수행되는 태스크에 굉장히 민감한데, 단 하나의 느린 태스크가 전체 잡 수행을 지연시키기 때문이다.  

하둡은 느린태스크를 진단하거나 고치려 하는 대신에 태스크 수행이 예상 시간보다 더 느린 상황을 감지하여 동일한 예비 태스크를 실행한다.  
이를 태스크의 **투기적 실행(speculative execution)** 이라고 한다.

동시에 두 개의 복제 태스크를 실행하여 서로 경쟁하는 것이 아니다.  
투기적 복제 태스크를 실행하면, 기존 태스크와 투기적 복제 태스크 둘 중 하나의 태스크가 성공적으로 완료되면 다른 중복 태스크는 더 이상 필요 없으므로 강제 종료된다.  

투기적 실행은 일종의 최적화이며 잡을 안정적으로 실행하는 기능은 아니다.  
따라서 태스크를 멈추거나 느리게 하는 버그가 있을 경우, 이 문제를 회피하기 위해 투기적 실행을 사용하는 것은 좋지 않은 방법이다.  

투기적 실행은 잡 실행 시간을 줄이는 것에는 도움이 될지 몰라도 클러스터 효율성 측면에서 비용이 발생하게 된다.  
