# es 의 실시간 검색을 위해

elasticsearch 는 실시간 검색을 위해 어떤 구조로 설계되어 있는지 알아보자

먼저 엘라스틱서치는 내부적으로 루씬을 통해 검색 기능을 수행한다.

엘라스틱 서치는 문서를 빠른 검색에 유리하도록 segment 라는 특수한 자료구조로 저장한다.

세그먼트는 읽기에 최적화된 자료구조로 역색인이라는 특수한 형태로 변환되어 디스크에 저장된다. 

![image](https://user-images.githubusercontent.com/37106689/197756213-5c20697e-1cac-426a-8d28-5e02a4dbde16.png)


하나의 루씬 인덱스는 내부적으로 여러개의 세그먼트로 구성되어 있다. 하나의 세그먼트로 검색 요청을 처리하는 것보다 나눠서 처리하는 것이 효율적이다.

루씬은 세그먼트들을 관리하기 위해 커밋 포인트라는 자료구조를 활용한다. 

커밋 포인트는 여러 세그먼트의 목록 정보를 갖고 있고, 검색시 이를 이용해 가장 오래된 세그먼트부터 검색 후 결과를 합쳐서 제공한다.

색인 요청이 들어올 때마다 새로운 세그먼트가 생성되고 커밋 포인트에 기록된다. 색인 작업이 일어날 때마다 세그먼트의 개수는 증가한다. (세그먼트는 불변이여서 항상 새로 생성된다)

색인 요청이 많아질수록 세그먼트의 개수가 빠르게 증가하고 이는 읽기 성능 저하로 이어지기 때문에, 루씬은 백그라운드에서 주기적으로 세그먼트를 병합하는 작업을 수행한다. (Merge)

- Merge 장점
    
    검색 성능이 좋아진다. 검색 요청시 모든 세그먼트를 검색해야 하는데, 세그먼트는 순차적으로 검색되므로 세그먼트 개수가 줄어들면 검색 횟수도 줄어든다.
    
    세그먼트가 차지하는 디스크 용량이 줄어든다. 삭제되는 문서는 Merge 전까지는 디스크에 물리적으로 남아있기 때문에 merge 시 용량을 줄일수 있다.


![image](https://user-images.githubusercontent.com/37106689/197756344-67b79e2e-5f7f-46d4-b91f-3ba0690885cf.png)

---

> 세그먼트를 불변으로 함으로써 얻는 장점
> 
- 동시성 문제 회피
    - 불변성이 보장되면 잠금이 필요 없어진다
- 시스템 캐시 활용
    - os 커널에서 제공하는 시스템 캐시에 데이터가 생성되면 일정 시간동안 유지된다. 불변성이 없다면 데이터 변경시마다 캐시를 갱신해야 하는데 이는 비용이 매우 큰 작업이다
- 높은 캐시 적중률
    - 캐시의 수명이 길어진다.
- 리소스 절감
    - 역색인 생성 과정에서 많은 시스템 리소스가 사용된다. 수정을 허용하면 일부분 변경시에도 해당 역색인을 다시 작업해야 하기 때문에 많은 리소스가 소모된다.

## 루씬의 Flush, Commit

하지만 색인 요청이 들어올때마다 매번 세그먼트를 생성하게 된다면, 혹은 너무 많은 색인 요청이 순간적으로 들어올 경우에 위의 세그먼트 구조만으로는 부족하다. 세그먼트는 어쨌든 디스크에 저장하는 것이기 때문에 지연이 있을 수 밖에 없다. 

### Flush

이를 위해 루씬은 내부적으로 인메모리 버퍼를 사용하고, 일정 크기 이상의 데이터가 쌓이거나 일정 시간이 흐를 경우 버퍼에 쌓인 데이터를 한번에 처리한다.

버퍼에 쌓인 데이터는 세그먼트 형태로 생성되고 디스크로 동기화 된다. 새로운 세그먼트가 생성되고 디스크에 동기화 하는 과정까지 거쳐야 검색이 가능해진다. 이러한 인메모리 버퍼 기반의 처리 과정을 Flush 라고 부른다

### Commit

디스크에 물리적으로 동기화하는 과정은 os 에서 비용이 매우 큰 연산이기 때문에 세그먼트 생성시마다 물리적인 동기화를 할 경우 성능이 하락한다. 이를 위해 루씬은 무거운 fsync 방식 보다는 write 방식을 이용해 쓰기 과정을 수행한다.

- fsync vs write
    - write
        - 운영체제 내부엔 시스템 캐시가 존재하는데, 일단 시스템 캐시에만 기록하고 리턴한다. 이후 일정 주기에 따라 물리적으로 디스크에 기록된다.
        - 물리적인 디스크 쓰기를 하지 않기 때문에 빠른 처리가 가능하지만 시스템이 비정상 종료될 경우에는 데이터 유실이 발생할 수 있다
    - fsync
        - 내부 시스템 캐시의 데이터와 물리적인 디스크의 데이터를 동기화 한다. 실제 물리적인 디스크로 쓰는 작업을 수행한다
        

루씬에서 물리적으로 디스크에 기록을 수행하는 fsync() 함수를 호출하는 작업을 Commit 이라고 한다. 

Flush 단계가 있기 때문에 매번 commit 을 할 필요는 없지만 일정 주기로 commit 을 해야한다.

## 엘라스틱서치의 Refresh, Flush, Optimize API

엘라스틱서치의 샤드는 사실상 루씬 인덱스의 확장이고, 세그먼트 기반의 동작을 그대로 활용한다.

따라서 루씬을 튜닝하면 es 도 성능상의 이점을 얻을수 있다.

위에서 말했던 루씬의 대표적인 튜닝 포인트인 Flush, Commit, Merge 도 활용할수 있지만 es 에서는 다른 명칭으로 쓰고 있어서 주의 해야 한다

| lucene | elasticsearch |
| --- | --- |
| Flush | Refresh |
| Commit | Flush |
| Merge | Optimize API |

루씬은 단일 노드 검색엔진이지만 엘라스틱서치는 분산 검색엔진이기 때문에 루신보다 조금더 고려해야 할 사항이 많아진다. 따라서 루씬의 Flush, Commit, Merge 를 그대로 사용하지 않고 개선 및 확장했다.

### Refresh

ES 는 각 샤드가 갖고 있는 루씬을 제어할수 있고, 주기적으로 인메모리 버퍼에 대해 Flush 작업을 수행한다. 이를 ES 에서는 Refresh 라고 부른다. 기본적으로 1초마다 수행된다.

### Flush

ES 의 Flush 는 루씬의 Commit 작업을 수행하고 새로운 Translog 를 시작한다는 의미이다. 

Translog 는 고가용성을 위해 엘라스틱서치에 도입된 개념이다. 

샤드의 장애 복구를 위한 특수한 파일이고, 샤드는 자신에게 일어나는 모든 변경사항을 translog 에 먼저 기록한 후 내부에 존재하는 루씬을 호출한다. 

시간이 흐를수록 translog 파일 크기는 늘어나고 샤드는 1초마다 refresh 를 수행한다.

지속적인 refresh 에 따라 검색은 가능하지만 아직은 디스크에 동기화된 상태는 아니기 때문에 주기적으로 루씬의 commit 을 실행해야 한다.

루씬의 commit 이 일어날때 변경사항이 디스크에 기록되고 Translog 파일도 커밋 시점까지의 내역이 삭제된다.

기본적으로 5초마다 수행된다

### Optimize API

인덱스 최적화를 위해 Optimize API 를 제공하고, forced merge API 라고도 한다.

루씬의 Merge 작업을 강제로 수행하는 작업이다.


> Translog  
>
> 엘라스틱서치는 고가용성을 위해 특수한 로그파일인 translog 를 사용한다
> 각 샤드는 샤드의 변경사항을 translog 에 기록하고 ES Flush 가 fsync를 호출할때 까지의 변경 내역을 기록한다
> Flush 가 성공하고 물리적으로 디스크에 동기화 되면 그 시점까지의 파일 내용이 삭제된다
> 
> 
> 동작순서
> 1. 데이터가 추가되면 translog 에 기록되고 인메모리 버퍼에 추가된다
> 2. Refresh 가 수행되면 인메모리 버퍼에서는 사라지지만 translog 에는 남아있다
> 3. 더 많은 데이터가 추가되고 지속적으로 세그먼트가 추가된다
> 4. Translog 가 일정 크기 이상으로 커지면 Flush 가 수행된다
> 5. 커밋 포인트가 디스크에 Flush 된다
> 6. 시스템 캐시의 내용이 디스크에 Flush 된다
> 7. Translog의 기록이 삭제된다